package s_lqcd;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamPortMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamPortParams;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class HalfSpinorBuffer extends KernelLib {

	private final int singleBRAMdepth = 512;

	private final QCDConstants m_constants;

	private DFEVar write_t, write_x, write_y, write_z;

	private final DFEVar write_iter;
	private DFEVar read_t,  read_x,  read_y,  read_z;

	private final DFEVar read_iter;

	private DFEVar writeEnable;
	private final DFESu3Vector[] m_bufferIn;
	private DFESu3Vector[] m_bufferOut;

	int LX, LY, LZ, T;
	int m_numPipes, m_vectorsPerSite;

	int bufferDepth, bufferDepthTF, bufferDepthTB;

	protected HalfSpinorBuffer(QCDConstants constants) {
		super(constants.getKernel());
		m_constants = constants;
		LX = m_constants.LX;
		LY = m_constants.LY;
		LZ = m_constants.LZ;
		T  = m_constants.T;
		m_numPipes = m_constants.numPipes;
		m_vectorsPerSite = 16/m_numPipes;

		int loopOffset = m_constants.loopOffset;

		bufferDepth   = MathUtils.nextMultiple(m_vectorsPerSite*(loopOffset + 20 + 2*LX*LY*LZ/2), singleBRAMdepth);
		//bufferDepthTF = MathUtils.nextMultiple(m_vectorsPerSite*loopOffset + 1 + 2*LX*LY*LZ/2, singleBRAMdepth);
		//bufferDepthTB = MathUtils.nextMultiple(m_vectorsPerSite*loopOffset + 1               , singleBRAMdepth);

		System.out.println("Depth: " + bufferDepth);

		Kernel owner = m_constants.getKernel();

		writeEnable = dfeBool().newInstance(owner);

		write_t    = dfeUInt(MathUtils.bitsToAddress(T+2*m_constants.halos)) .newInstance(owner);
		write_z    = dfeUInt(MathUtils.bitsToAddress(LZ))  .newInstance(owner);
		write_y    = dfeUInt(MathUtils.bitsToAddress(LY))  .newInstance(owner);
		write_x    = dfeUInt(MathUtils.bitsToAddress(LX/2)).newInstance(owner);
		write_iter = dfeUInt(MathUtils.bitsToAddress(m_vectorsPerSite)).newInstance(owner);

		read_t    = dfeUInt(MathUtils.bitsToAddress(T+2*m_constants.halos)) .newInstance(owner);
		read_z    = dfeUInt(MathUtils.bitsToAddress(LZ))  .newInstance(owner);
		read_y    = dfeUInt(MathUtils.bitsToAddress(LY))  .newInstance(owner);
		read_x    = dfeUInt(MathUtils.bitsToAddress(LX/2)).newInstance(owner);
		read_iter = dfeUInt(MathUtils.bitsToAddress(m_vectorsPerSite)).newInstance(owner);

		m_bufferIn = new DFESu3Vector[m_numPipes];
		m_bufferOut = new DFESu3Vector[m_numPipes];

		DFEVar[] readAddress = getReadAddresses(read_t, read_z, read_y, read_x, read_iter);

		DFEVar writeAddress  = getAddress(write_t, write_z, write_y, write_x, write_iter);

		for (int i=0 ; i<m_numPipes ; i++ ) {
			m_bufferIn[i] = new DFESu3Vector(m_constants);
		}

		m_bufferOut = createBuffer(
				m_bufferIn,
				writeAddress,
				readAddress,
				bufferDepth
				);
	}

	public void setWriteCoordinates(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter) {
		write_t <== t;
		write_z <== z;
		write_y <== y;
		write_x <== x;
		write_iter <== iter;
	}

	public void setReadCoordinates(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter) {
		read_t <== t;
		read_z <== z;
		read_y <== y;
		read_x <== x;
		read_iter <== iter;
	}

	public void setBufferIn(int pipe, DFESu3Vector in) {
		m_bufferIn[pipe] <== in;
	}

	public void setWriteEnable(DFEVar isEnabled) {
		writeEnable <== isEnabled;
	}

	public DFESu3Vector getBufferOut (int pipe) {
		return m_bufferOut[pipe];
	}

	private DFEVar mod(DFEVar dividend, int divisor) {
		if (MathUtils.isPowerOf2(divisor)) {
			return (dividend & (divisor-1));
		} else {
			optimization.pushRoundingMode(RoundingMode.TRUNCATE);
			DFEVar divisor_ = constant.var(
					dfeUInt(MathUtils.bitsToRepresent(divisor)),
					divisor
					);
			DFEVar quotient = (dividend / divisor)
			                  .cast(dfeUInt(dividend.getType().getTotalBits()));
			DFEVar remainder = dividend - quotient * divisor_;
			optimization.popRoundingMode();
			return remainder;
		}
	}

	private DFESu3Vector[] createBuffer(
			DFESu3Vector[] halfSpinor_in,
            DFEVar writeAddress,
            DFEVar[] readAddress,
			int bufferDepth)
	{
		DFESu3Vector[] bufferOutput = new DFESu3Vector[m_numPipes];

		for (int i = 0 ; i < m_numPipes ; i ++ ) {
			DFEVector<DFEComplex> in = halfSpinor_in[i].convertToDFEVector();
			RamPortParams<DFEVector<DFEComplex>> writePort =
				mem.makeRamPortParams(
						RamPortMode.WRITE_ONLY,
						writeAddress,
						QCDConstants.getVectoredSu3VectorType()
						)
						.withDataIn(in)
						.withWriteEnable(writeEnable);

			RamPortParams<DFEVector<DFEComplex>> readPort  =
				mem.makeRamPortParams(
						RamPortMode.READ_ONLY,
						readAddress[i],
						QCDConstants.getVectoredSu3VectorType());

			DFEVector<DFEComplex> ram =
				mem.ramDualPort(
						bufferDepth,
						RamWriteMode.READ_FIRST,
						writePort,
						readPort)
						.getOutputB();

			bufferOutput[i] = new DFESu3Vector(m_constants, ram);

		}

		return bufferOutput;
	}

	private DFEVar[] getReadAddresses(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter) {

		DFEVar addresses[] = new DFEVar[m_numPipes];

		/*t.simWatch("t");
		z.simWatch("z");
		iter.simWatch("iter");
		y.simWatch("y");
		x.simWatch("x");*/

		optimization.pushEnableBitGrowth(true);

		DFEVar isOddRow =
			(t&1).cast(dfeBool()) ^
			(z&1).cast(dfeBool()) ^
			(y&1).cast(dfeBool()) ^
			(m_constants.halos&1);
		if (m_constants.ieo == S_LQCDKernel.EO.EVENODD) isOddRow ^= 1;

		DFEVar xn = mod(x + LX - 1 + isOddRow, LX/2)
		            .cast(dfeUInt(MathUtils.bitsToAddress(LX/2)));
		DFEVar xp = mod(x + LX + 0 + isOddRow, LX/2)
		            .cast(dfeUInt(MathUtils.bitsToAddress(LX/2)));
		DFEVar yn = mod(y - 1, LY).cast(dfeUInt(MathUtils.bitsToAddress(LY)));
		DFEVar yp = mod(y + 1, LY).cast(dfeUInt(MathUtils.bitsToAddress(LY)));
		DFEVar zn = mod(z - 1, LZ).cast(dfeUInt(MathUtils.bitsToAddress(LZ)));
		DFEVar zp = mod(z + 1, LZ).cast(dfeUInt(MathUtils.bitsToAddress(LZ)));
		DFEVar tn = (t - 1).cast(dfeUInt(MathUtils.bitsToAddress(T+2*m_constants.halos)));
		DFEVar tp = (t + 1).cast(dfeUInt(MathUtils.bitsToAddress(T+2*m_constants.halos)));

		optimization.popEnableBitGrowth();

		DFEVar numPipes_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(m_numPipes)), m_numPipes);

		for (int pipe = 0 ; pipe < m_numPipes ; pipe ++ ) {

			DFEVar pipe_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(m_numPipes)), pipe);

			optimization.pushEnableBitGrowth(true);
			DFEVar mu = (iter * numPipes_ + pipe_) >> 1;
			optimization.popEnableBitGrowth();

			x = (mu === 0) ? xn : x;
			x = (mu === 1) ? xp : x;
			y = (mu === 2) ? yn : y;
			y = (mu === 3) ? yp : y;
			z = (mu === 4) ? zn : z;
			z = (mu === 5) ? zp : z;
			t = (mu === 6) ? tn : t;
			t = (mu === 7) ? tp : t;

			/*mu.simWatch("mu"+pipe);
			t.simWatch("t_"+pipe);
			z.simWatch("z_"+pipe);
			y.simWatch("y_"+pipe);
			x.simWatch("x_"+pipe);*/
			addresses[pipe] = getAddress(t, z, y, x, iter);
			//addresses[pipe].simWatch("address_"+pipe);
		}


		return addresses;

	}

	public DFEVar getAddress(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter) {

		DFEVar LZ_  = constant.var(dfeUInt(MathUtils.bitsToRepresent(LZ)),LZ);
		DFEVar LY_  = constant.var(dfeUInt(MathUtils.bitsToRepresent(LY)),LY);
		DFEVar LXH_ = constant.var(dfeUInt(MathUtils.bitsToRepresent(LX/2)),LX/2);

		optimization.pushEnableBitGrowth(true);

		DFEVar address = ( ( ( ( t*LZ_ + z) * LY_ + y) * LXH_ + x) * m_vectorsPerSite + iter );
		address = mod(address, bufferDepth);  //wrap around, whenever passed the buffer capacity

		optimization.popEnableBitGrowth();
		return address.cast(dfeUInt(MathUtils.bitsToAddress(bufferDepth)));
	}


}
