package s_lqcd;

import com.maxeler.maxcompiler.v0.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;

class S_LQCDKernel extends Kernel {

	public enum Mode {
		TIMES, SUB
	}

	public enum EO {
		EVENODD, ODDEVEN
	}

	protected S_LQCDKernel(
			KernelParameters parameters,
			int T,
			int LX,
			int LY,
			int LZ,
			int numPipes,
			int loopOffset,
			Mode mode,
			EO ieo,
			boolean passGauge
			)
	{

		super(parameters);

		int ticksPerSite = 16/numPipes;

		QCDConstants constants = new QCDConstants(
				this,
				LX,
				LY,
				LZ,
				T,
				numPipes,
				loopOffset);

		HalfSpinorBuffer buffer = new HalfSpinorBuffer(constants);

		optimization.pushPipeliningFactor(0.1);
		CounterChain tickChain = control.count.makeCounterChain();
		DFEVar tick = tickChain.addCounter(
				ticksPerSite *( (T+2)*LZ*LY*LX/2 + loopOffset ) + 2,
				1);

		DFEVar writeChainEnable = tick < ( ticksPerSite*(T+2)*LZ*LY*LX/2 ) ;
		DFEVar readChainEnable  = tick > ( ticksPerSite*(2*LZ*LY*LX/2 + loopOffset) + 1) ;


		CounterChain writeChain = control.count.makeCounterChain(writeChainEnable);
		DFEVar t = writeChain.addCounter(T+2, 1);
		DFEVar z = writeChain.addCounter(LZ, 1);
		DFEVar y = writeChain.addCounter(LY, 1);
		DFEVar x = writeChain.addCounter(LX/2, 1);
		DFEVar iter = writeChain.addCounter(16/numPipes, 1);

		buffer.setWriteEnable(writeChainEnable);
		buffer.setWriteCoordinates(t, z, y, x, iter);

		DFEVar isOddRow = (t&1).cast(dfeBool()) ^
		                  (x&1).cast(dfeBool()) ^
		                  (y&1).cast(dfeBool()) ;
		if (ieo == EO.EVENODD) isOddRow = isOddRow ^ 1;

		DFEVector<DFEComplex> spinor_in =
			io.input(
				parameters.getName()+"_spinor_in",
				QCDConstants.getVectoredSpinorType(),
				writeChainEnable & (iter===0)
				);
		DFEVector<DFEComplex> gauge0_in =
			io.input(
					parameters.getName()+"_gauge0",
					QCDConstants.getVectoredSu3Type(),
					writeChainEnable );
		DFEVector<DFEComplex> gauge1_in =
			io.input(
					parameters.getName()+"_gauge1",
					QCDConstants.getVectoredSu3Type(),
					writeChainEnable);

		/*DFEVector<DFEComplex> p_spinor_in = null;
		if (mode == Mode.SUB ) {
			p_spinor_in = io.input(
			parameters.getName()+"_p_spinor_in",
			DFESpinor.getDFESpinorType(),
			~isOnBoundary);
		}*/

		/*DFEVar cfactor_r = io.scalarInput("cfactor", dfeFloat(8,24) );
		DFEVar ka0_r     = io.scalarInput("ka0", dfeFloat(8,24) );
		DFEVar ka1_r     = io.scalarInput("ka1", dfeFloat(8,24) );
		DFEVar ka2_r     = io.scalarInput("ka2", dfeFloat(8,24) );
		DFEVar ka3_r     = io.scalarInput("ka3", dfeFloat(8,24) );

		DFEComplex cfactor = QCDConstants.dataType.newInstance(this);
		cfactor.setReal(cfactor_r);
		cfactor.setImaginary(constant.var(dfeFloat(8,24),0));
		DFEComplex ka0 = QCDConstants.dataType.newInstance(this);
		ka0.setReal(ka0_r);
		ka0.setImaginary(constant.var(dfeFloat(8,24),0));
		DFEComplex ka1 = QCDConstants.dataType.newInstance(this);
		ka1.setReal(ka1_r);
		ka1.setImaginary(constant.var(dfeFloat(8,24),0));
		DFEComplex ka2 = QCDConstants.dataType.newInstance(this);
		ka2.setReal(ka2_r);
		ka2.setImaginary(constant.var(dfeFloat(8,24),0));
		DFEComplex ka3 = QCDConstants.dataType.newInstance(this);
		ka3.setReal(ka3_r);
		ka3.setImaginary(constant.var(dfeFloat(8,24),0));*/

		DFESpinor k = new DFESpinor(constants, spinor_in);
		DFESu3 gauge0 = new DFESu3(constants, gauge0_in);
		DFESu3 gauge1 = new DFESu3(constants, gauge1_in);
		//DFESpinor p = null;
		/*if (mode == Mode.SUB ) {
			p = new DFESpinor(this, p_spinor_in);
		}*/

		DFESu3Vector alpha, beta;
		DFESu3Vector psi;
		DFESu3 g;

		DFEVar numPipes_ = constant.var(dfeUInt(MathUtils.bitsToRepresent(numPipes)),numPipes);

		for (int i = 0; i < numPipes ; i++ ) {

			DFEVar i_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(numPipes)), i);

			optimization.pushEnableBitGrowth(true);
			DFEVar index = (iter*numPipes_ + i_);
			optimization.popEnableBitGrowth();
			DFEVar mu  = index >> 1;  // divide by 2 (truncates)
			DFEVar dir = mu >> 1;     // divide by 2 (truncates)
			DFEVar vec = index & 1;

			DFEVar vec0 = vec === 0;
			DFEVar dir23 = (dir === 2 | dir === 3);
			DFEVar mu17 = mu === 1 | mu === 7;
			DFEVar mu25 = mu === 2 | mu === 5;
			DFEVar mu34 = mu === 3 | mu === 4;

			DFEQCDSelector alphaS0Selector  = new DFEQCDSelector(constants, vec0 );
			DFEQCDSelector betaS2Selector   = new DFEQCDSelector(constants, vec0 & dir23 | (~vec0) & (~dir23) );
			DFEQCDSelector betaNegSelector  = new DFEQCDSelector(constants, mu17 | (vec0 & mu25) | (~vec0 & mu34) );
			DFEQCDSelector betaConjSelector = new DFEQCDSelector(constants, dir === 0 | dir === 2 );
			DFEQCDSelector gTransSelector   = new DFEQCDSelector(constants, (mu&1) === 1);

			alpha  = alphaS0Selector  ? k.s0 : k.s1 ;
			beta   = betaS2Selector   ? k.s2 : k.s3 ;
			beta   = betaNegSelector  ? -beta : beta ;
			beta   = betaConjSelector ? beta.mult_i() : beta ;
			psi    = alpha + beta;
			g      = gTransSelector ? gauge1.transpose() : gauge0.conjugate() ;
			psi = g * psi;
			buffer.setBufferIn(i, psi);

			/*if (i==0) debug.simPrintf(
			t !== 0 & t !== T+1 ,
			"dfe pre %f %f %f %f %f %f\n",
			psi.c0.getReal(),
			psi.c0.getImaginary(),
			psi.c1.getReal(),
			psi.c1.getImaginary(),
			psi.c2.getReal(),
			psi.c2.getImaginary());*/

		}

		DFEVar loopOffset_ = constant.var(
				dfeUInt(MathUtils.bitsToRepresent(loopOffset)),
				loopOffset
				);
		DFEVar LXH_ = constant.var(
				dfeUInt( MathUtils.bitsToRepresent(LX/2)),
				LX/2
				);

		//readChainEnable.simWatch("en");

		CounterChain chain2 = control.count.makeCounterChain(readChainEnable);
		DFEVar tr  = chain2.addCounter(T, 1);
		DFEVar zr  = chain2.addCounter(LZ, 1);
		DFEVar yxr  = (LY*LX/2 > loopOffset) ?
					chain2.addCounter(LY*LX/2/loopOffset, 1) : constant.var(0);
		DFEVar iterr = chain2.addCounter(16/numPipes, 1);
		DFEVar yxrloop = chain2.addCounter(loopOffset, 1);



		optimization.pushEnableBitGrowth(true);
		optimization.pushRoundingMode(RoundingMode.TRUNCATE);

		yxr = yxr * loopOffset_ + yxrloop;
		DFEVar yr = (yxr / (LXH_))
		            .cast(dfeUInt(MathUtils.bitsToAddress(LY)));
		DFEVar xr = (yxr - yr * LXH_)
		            .cast(dfeUInt(MathUtils.bitsToAddress(LX/2)));

		optimization.popRoundingMode();
		optimization.popEnableBitGrowth();

		tr = tr.cast(dfeUInt(MathUtils.bitsToAddress(T+2)));
		zr = zr.cast(dfeUInt(MathUtils.bitsToAddress(LZ)));

		buffer.setReadCoordinates(tr+1, zr, yr, xr, iterr);

		DFESpinor addend = new DFESpinor(constants);
		addend.newZeroInstant();

		System.out.println("p: "+numPipes);
		if (numPipes>1) {

			DFESpinor[] addends = new DFESpinor[numPipes/2];
			DFEHalfSpinor phi = new DFEHalfSpinor(constants);

			for (int i = 0; i < numPipes/2 ; i++ ) {

				phi.s0 = buffer.getBufferOut(i*2);
				phi.s1 = buffer.getBufferOut(i*2+1);

				DFEVar i_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(numPipes)), i);

				optimization.pushEnableBitGrowth(true);
				DFEVar index = (iterr*numPipes_ + i_*2);
				optimization.popEnableBitGrowth();
				DFEVar mu  = index >> 1;  // divide by 2 (truncates)
				DFEVar dir = mu >> 1;     // divide by 2 (truncates)
				DFEVar mu07 = mu === 0 | mu === 7;
				DFEVar mu34 = mu === 3 | mu === 4;
				DFEVar mu25 = mu === 2 | mu === 5;

				DFEQCDSelector addends2S1Select = new DFEQCDSelector (constants, dir === 0 | dir === 1 );
				DFEQCDSelector addendsMultISelect = new DFEQCDSelector (constants, dir === 0 | dir === 2 );
				DFEQCDSelector addends2NegSelect = new DFEQCDSelector (constants, mu07 | mu34);
				DFEQCDSelector addends3NegSelect = new DFEQCDSelector (constants, mu07 | mu25);

				addends[i] = new DFESpinor(constants);
				addends[i].s0 = phi.s0;
				addends[i].s1 = phi.s1;

				addends[i].s2 = addends2S1Select   ? phi.s1                 : phi.s0 ;
				addends[i].s2 = addendsMultISelect ? addends[i].s2.mult_i() : addends[i].s2 ;
				addends[i].s2 = addends2NegSelect  ? -addends[i].s2         : addends[i].s2 ;

				addends[i].s3 = addends2S1Select   ? phi.s0                 : phi.s1 ;
				addends[i].s3 = addendsMultISelect ? addends[i].s3.mult_i() : addends[i].s3 ;
				addends[i].s3 = addends3NegSelect  ? -addends[i].s3         : addends[i].s3 ;

				/*debug.simPrintf(
						readChainEnable,
						"dfe_post %f %f %f %f %f %f\n",
						phi.s0.c0.getReal(),
						phi.s0.c0.getImaginary(),
						phi.s0.c1.getReal(),
						phi.s0.c1.getImaginary(),
						phi.s0.c2.getReal(),
						phi.s0.c2.getImaginary());*/
			}

			for (int i = 0; i < numPipes/2 ; i++ ) {
				addend.s0 += addends[i].s0;
				addend.s1 += addends[i].s1;
				addend.s2 += addends[i].s2;
				addend.s3 += addends[i].s3;
			}

		} else {
			//TODO support a single pipe
			throw new RuntimeException("A single pipe is not currently supported");
		}

		DFESpinor rs = new DFESpinor(constants);
		DFESpinor accumulator = new DFESpinor(constants);

		rs.newInstant();
		accumulator = rs.streamoffset(-loopOffset) + addend;

		DFEQCDSelector newSum = new DFEQCDSelector (constants, iterr===0 );

		rs.s0 <== newSum ? addend.s0 : accumulator.s0;
		rs.s1 <== newSum ? addend.s1 : accumulator.s1;
		rs.s2 <== newSum ? addend.s2 : accumulator.s2;
		rs.s3 <== newSum ? addend.s3 : accumulator.s3;


		/*DFESpinor result = new DFESpinor(constants);
		if (mode == Mode.TIMES) {
			result.s0 = rs.s0.times_complex(cfactor);
			result.s1 = rs.s1.times_complex(cfactor);
			result.s2 = rs.s2.times_complexcjg(cfactor);
			result.s3 = rs.s3.times_complexcjg(cfactor);
		} else if (mode == Mode.SUB) {
			psi = p.s0.times_complex(cfactor);
			result.s0 = psi.sub(rs.s0);
			psi2 = p.s1.times_complex(cfactor);
			result.s1 = psi2.sub(rs.s1);
			psi = p.s2.times_complexcjg(cfactor);
			result.s2 = rs.s2.sub(psi);
			psi2 = p.s3.times_complexcjg(cfactor);
			result.s3 = rs.s3.sub(psi2);
		}*/
		DFEVector<DFEComplex> spinor_out = rs.convertToDFEVector();

		io.output(
				parameters.getName()+"_spinor_out",
				spinor_out,
				QCDConstants.getVectoredSpinorType(),
				(readChainEnable & (iterr===(16/numPipes-1)) )
				);

		if (passGauge == true) {
			io.output(
					parameters.getName()+"_gauge0_out",
					gauge0_in,
					QCDConstants.getVectoredSu3Type());
			io.output(
					parameters.getName()+"_gauge1_out",
					gauge1_in,
					QCDConstants.getVectoredSu3Type());
			if (mode == Mode.TIMES) {
				io.output(
						parameters.getName()+"_p_spinor_out",
						spinor_in,
						QCDConstants.getVectoredSpinorType());
			}
		}

	}

}
