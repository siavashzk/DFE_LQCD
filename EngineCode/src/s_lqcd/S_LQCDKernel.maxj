package s_lqcd;

import com.maxeler.maxcompiler.v0.utils.MathUtils;
import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;

class S_LQCDKernel extends Kernel {

	public enum Mode {
		TIMES, SUB
	}

	public enum EO {
		EVENODD, ODDEVEN
	}

	protected S_LQCDKernel(
			KernelParameters parameters,
			int T,
			int LX,
			int LY,
			int LZ,
			int numPipes,
			int loopOffset,
			Mode mode,
			EO ieo,
			int halos,
			boolean passGauge
			)
	{

		super(parameters);

		int ticksPerSite = 16/numPipes;

		QCDConstants constants = new QCDConstants(
				this,
				LX,
				LY,
				LZ,
				T,
				numPipes,
				loopOffset,
				halos,
				ieo);

		HalfSpinorBuffer buffer = new HalfSpinorBuffer(constants);

		optimization.pushPipeliningFactor(0.1);
		CounterChain tickChain = control.count.makeCounterChain();
		DFEVar tick = tickChain.addCounter(
				ticksPerSite *( (T+2*halos)*LZ*LY*LX/2 + loopOffset ) + 2,
				1);

		DFEVar writeChainEnable = tick < ( ticksPerSite*(T+2*halos)*LZ*LY*LX/2 ) ;
		DFEVar readChainEnable  = tick > ( ticksPerSite*(2*LZ*LY*LX/2 + loopOffset) + 1) ;


		CounterChain writeChain = control.count.makeCounterChain(writeChainEnable);
		DFEVar t = writeChain.addCounter(T+2*halos, 1);
		DFEVar z = writeChain.addCounter(LZ, 1);
		DFEVar y = writeChain.addCounter(LY, 1);
		DFEVar x = writeChain.addCounter(LX/2, 1);
		DFEVar iter = writeChain.addCounter(16/numPipes, 1);

		buffer.setWriteEnable(writeChainEnable);
		buffer.setWriteCoordinates(t, z, y, x, iter);

		DFEVector<DFEComplex> spinor_in =
			io.input(
				parameters.getName()+"_spinor_in",
				QCDConstants.getVectoredSpinorType(),
				writeChainEnable & (iter===0)
				);
		DFEVector<DFEComplex> gauge_in =
			io.input(
					parameters.getName()+"_gauge",
					QCDConstants.getVectoredSu3Type(),
					writeChainEnable );
		/*DFEVector<DFEComplex> gauge1_in =
			io.input(
					parameters.getName()+"_gauge1",
					QCDConstants.getVectoredSu3Type(),
					writeChainEnable & ((iter&1)===1));*/

		DFEVar beta_s   = io.scalarInput("beta_s",   QCDConstants.realType );
		DFEVar beta_t_f = io.scalarInput("beta_t_f", QCDConstants.realType );
		DFEVar beta_t_b = io.scalarInput("beta_t_b", QCDConstants.realType );

		DFESpinor k = new DFESpinor(constants, spinor_in);
		DFESu3 gauge = new DFESu3(constants, gauge_in);
		//DFESu3 gauge1 = new DFESu3(constants, gauge1_in);

		DFESu3Vector a, b;
		DFESu3Vector psi;
		DFESu3 g;
		DFEVar coeff;

		DFEVar numPipes_ = constant.var(dfeUInt(MathUtils.bitsToRepresent(numPipes)),numPipes);

		for (int i = 0; i < numPipes ; i++ ) {

			DFEVar i_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(numPipes)), i);

			optimization.pushEnableBitGrowth(true);
			DFEVar index = (iter*numPipes_ + i_);
			optimization.popEnableBitGrowth();
			DFEVar mu  = index >> 1;  // divide by 2 (truncates)
			DFEVar dir = mu >> 1;     // divide by 2 (truncates)
			DFEVar vec = index & 1;

			DFEVar vec0 = vec === 0;
			DFEVar dir23 = (dir === 2 | dir === 3);
			DFEVar mu17 = mu === 1 | mu === 7;
			DFEVar mu25 = mu === 2 | mu === 5;
			DFEVar mu34 = mu === 3 | mu === 4;

			DFEQCDSelector aS0Selector    = new DFEQCDSelector(constants, vec0 );
			DFEQCDSelector bS2Selector    = new DFEQCDSelector(constants, vec0 & dir23 | (~vec0) & (~dir23) );
			DFEQCDSelector bNegSelector   = new DFEQCDSelector(constants, mu17 | (vec0 & mu25) | (~vec0 & mu34) );
			DFEQCDSelector bMultISelector = new DFEQCDSelector(constants, dir === 0 | dir === 2 );
			DFEQCDSelector gTransSelector = new DFEQCDSelector(constants, (mu&1) === 1);

			a = aS0Selector    ? k.s0 : k.s1 ;
			b = bS2Selector    ? k.s2 : k.s3 ;
			b = bNegSelector   ? -b         : b ;
			b = bMultISelector ? b.mult_i() : b ;
			psi = a + b;
			g = gTransSelector ? gauge.transpose() : gauge.conjugate() ;
			psi = g * psi;
			coeff = (mu < 6) ? beta_s : ( (mu===6) ? beta_t_b : beta_t_f );
			psi = psi * coeff;
			buffer.setBufferIn(i, psi);

			/*if (i==0) debug.simPrintf(
					t !== 0 & t !== T+1 ,
					"dfe pre %f %f %f %f %f %f\n",
					psi.c0.getReal(),
					psi.c0.getImaginary(),
					psi.c1.getReal(),
					psi.c1.getImaginary(),
					psi.c2.getReal(),
					psi.c2.getImaginary());*/

		}

		DFEVar loopOffset_ = constant.var(
				dfeUInt(MathUtils.bitsToRepresent(loopOffset)),
				loopOffset
				);
		DFEVar LXH_ = constant.var(
				dfeUInt( MathUtils.bitsToRepresent(LX/2)),
				LX/2
				);

		//readChainEnable.simWatch("en");

		CounterChain chain2 = control.count.makeCounterChain(readChainEnable);
		DFEVar tr  = chain2.addCounter(T+2*(halos-1), 1);
		DFEVar zr  = chain2.addCounter(LZ, 1);
		DFEVar yxr  = (LY*LX/2 > loopOffset) ?
					chain2.addCounter(LY*LX/2/loopOffset, 1) : constant.var(0);
		DFEVar iterr = chain2.addCounter(16/numPipes, 1);
		DFEVar yxrloop = chain2.addCounter(loopOffset, 1);



		optimization.pushEnableBitGrowth(true);
		optimization.pushRoundingMode(RoundingMode.TRUNCATE);

		yxr = yxr * loopOffset_ + yxrloop;
		DFEVar yr = (yxr / (LXH_))
		            .cast(dfeUInt(MathUtils.bitsToAddress(LY)));
		DFEVar xr = (yxr - yr * LXH_)
		            .cast(dfeUInt(MathUtils.bitsToAddress(LX/2)));

		optimization.popRoundingMode();
		optimization.popEnableBitGrowth();

		tr = tr.cast(dfeUInt(MathUtils.bitsToAddress(T+2*halos)));
		zr = zr.cast(dfeUInt(MathUtils.bitsToAddress(LZ)));

		buffer.setReadCoordinates(tr+1, zr, yr, xr, iterr);

		DFESpinor addend2 = new DFESpinor(constants);
		addend2.newZeroInstant();

		System.out.println("p: "+numPipes);
		if (numPipes>1) {

			DFESpinor[] addends = new DFESpinor[numPipes/2];
			DFEHalfSpinor phi = new DFEHalfSpinor(constants);

			for (int i = 0; i < numPipes/2 ; i++ ) {

				phi.s0 = buffer.getBufferOut(i*2);
				phi.s1 = buffer.getBufferOut(i*2+1);

				DFEVar i_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(numPipes)), i);

				optimization.pushEnableBitGrowth(true);
				DFEVar index = (iterr*numPipes_ + i_*2);
				optimization.popEnableBitGrowth();
				DFEVar mu  = index >> 1;  // divide by 2 (truncates)
				DFEVar dir = mu >> 1;     // divide by 2 (truncates)
				DFEVar mu07 = mu === 0 | mu === 7;
				DFEVar mu34 = mu === 3 | mu === 4;
				DFEVar mu25 = mu === 2 | mu === 5;

				DFEQCDSelector addends2S1Select = new DFEQCDSelector (constants, dir === 0 | dir === 1 );
				DFEQCDSelector addendsMultISelect = new DFEQCDSelector (constants, dir === 0 | dir === 2 );
				DFEQCDSelector addends2NegSelect = new DFEQCDSelector (constants, mu07 | mu34);
				DFEQCDSelector addends3NegSelect = new DFEQCDSelector (constants, mu07 | mu25);

				addends[i] = new DFESpinor(constants);
				addends[i].s0 = phi.s0;
				addends[i].s1 = phi.s1;

				addends[i].s2 = addends2S1Select   ? phi.s1                 : phi.s0 ;
				addends[i].s2 = addendsMultISelect ? addends[i].s2.mult_i() : addends[i].s2 ;
				addends[i].s2 = addends2NegSelect  ? -addends[i].s2         : addends[i].s2 ;

				addends[i].s3 = addends2S1Select   ? phi.s0                 : phi.s1 ;
				addends[i].s3 = addendsMultISelect ? addends[i].s3.mult_i() : addends[i].s3 ;
				addends[i].s3 = addends3NegSelect  ? -addends[i].s3         : addends[i].s3 ;

				/*debug.simPrintf(
						readChainEnable,
						"dfe_post %f %f %f %f %f %f\n",
						phi.s0.c0.getReal(),
						phi.s0.c0.getImaginary(),
						phi.s0.c1.getReal(),
						phi.s0.c1.getImaginary(),
						phi.s0.c2.getReal(),
						phi.s0.c2.getImaginary());*/
			}

			for (int i = 0; i < numPipes/2 ; i++ ) {
				addend2.s0 += addends[i].s0;
				addend2.s1 += addends[i].s1;
				addend2.s2 += addends[i].s2;
				addend2.s3 += addends[i].s3;
			}

		} else {
			//TODO support a single pipe
			throw new RuntimeException("A single pipe is not currently supported");
		}

		//DFESpinor rs = new DFESpinor(constants);
		DFESpinor addend1     = new DFESpinor(constants);
		DFESpinor accumulator = new DFESpinor(constants);
		DFESpinor initAddend  = null;// new DFESpinor(constants);
		DFEVector<DFEComplex> p_spinor_in = null;
		//DFESpinor p = null;
		DFEVar alpha = null;

		accumulator.newInstant();
		if (mode == Mode.SUB ) {
			alpha = io.scalarInput("alpha",   QCDConstants.realType );
			p_spinor_in = io.input(
					parameters.getName()+"_p_spinor_in",
					QCDConstants.getVectoredSpinorType(),
					readChainEnable & (iterr===0)
					);
			initAddend = new DFESpinor(constants, p_spinor_in);
			initAddend = initAddend * alpha;
			addend2 = -addend2;

		} else {
			initAddend = new DFESpinor(constants);
			initAddend.newZeroInstant();
		}

		DFEQCDSelector newSum = new DFEQCDSelector (constants, iterr===0 );

		addend1 = newSum ? initAddend : accumulator.streamoffset(-loopOffset);

		accumulator <== addend1 + addend2;

		/*debug.simPrintf(
				readChainEnable,
				"dfe_post %f %f %f %f %f %f\n",
				addend1.s0.c0.getReal(),
				addend1.s0.c0.getImaginary(),
				addend1.s0.c1.getReal(),
				addend1.s0.c1.getImaginary(),
				addend1.s0.c2.getReal(),
				addend1.s0.c2.getImaginary());*/
		/*debug.simPrintf(
				readChainEnable,
				"dfe_post %f %f %f %f %f %f\n",
				accumulator.s0.c0.getReal(),
				accumulator.s0.c0.getImaginary(),
				accumulator.s0.c1.getReal(),
				accumulator.s0.c1.getImaginary(),
				accumulator.s0.c2.getReal(),
				accumulator.s0.c2.getImaginary());*/

		/*rs.newInstant();
		accumulator = rs.streamoffset(-loopOffset) + addend2;


		rs.s0 <== newSum ? addend.s0 : accumulator.s0;
		rs.s1 <== newSum ? addend.s1 : accumulator.s1;
		rs.s2 <== newSum ? addend.s2 : accumulator.s2;
		rs.s3 <== newSum ? addend.s3 : accumulator.s3;*/

		//DFESpinor result = new DFESpinor(constants);
		/*if (mode == Mode.TIMES) {
			result.s0 = rs.s0;
			result.s1 = rs.s1;
			result.s2 = rs.s2;
			result.s3 = rs.s3;
		} else if (mode == Mode.SUB) {
			result.s0 = p.s0 * alpha - rs.s0;
			result.s1 = p.s1 * alpha - rs.s1;
			result.s2 = p.s2 * alpha - rs.s2;
			result.s3 = p.s3 * alpha - rs.s3;
		}*/
		DFEVector<DFEComplex> spinor_out = accumulator.convertToDFEVector();


		io.output(
				parameters.getName()+"_spinor_out",
				spinor_out,
				QCDConstants.getVectoredSpinorType(),
				readChainEnable & (iterr===(16/numPipes-1))
				);

		if (passGauge == true) {
			/*io.output(
					parameters.getName()+"_gauge0_out",
					gauge0_in,
					QCDConstants.getVectoredSu3Type());
			io.output(
					parameters.getName()+"_gauge1_out",
					gauge1_in,
					QCDConstants.getVectoredSu3Type());*/
			if (mode == Mode.TIMES) {
				io.output(
						parameters.getName()+"_p_spinor_out",
						spinor_in,
						QCDConstants.getVectoredSpinorType(),
						writeChainEnable & (iter===0) & ( t > 1 ) & ( t < T+2*halos-2 ) );
			}
		}

	}

}
