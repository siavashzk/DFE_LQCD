package lqcd;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamPortMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamPortParams;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEComplex;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

/**
 * This class instantiates a buffer for caching halfspinors that are produced by dslash operator
 * @author Siavash Zangeneh
 *
 */
public class HalfSpinorBuffer extends KernelLib {

	private final int singleBRAMdepth = 512;

	private final LQCDConstants m_constants;

	private DFEVar write_t, write_x, write_y, write_z;

	private final DFEVar write_iter;
	private DFEVar read_t,  read_x,  read_y,  read_z, m_ieo;

	private final DFEVar read_iter;

	private DFEVar writeEnable;
	private final DFESu3Vector[] m_bufferIn;
	private DFESu3Vector[] m_bufferOut;

	int LX, LY, LZ, T;
	int m_numPipes, m_vectorsPerSite;

	int bufferDepth;

	protected HalfSpinorBuffer(LQCDConstants constants) {
		super(constants.getKernel());
		m_constants = constants;
		LX = m_constants.LX;
		LY = m_constants.LY;
		LZ = m_constants.LZ;
		T  = m_constants.T;
		m_numPipes = m_constants.numPipes;
		m_vectorsPerSite = 16/m_numPipes;

		int loopOffset = m_constants.loopOffset;

		// the buffer should cache 2XYZ/2 referring to two previous time-slices
		// some extra room is allocated for the loop iterations in phase 2
		bufferDepth   = MathUtils.nextMultiple(m_vectorsPerSite*(loopOffset + 20 + 2*LX*LY*LZ/2), singleBRAMdepth);

		System.out.println("Depth: " + bufferDepth);

		Kernel owner = m_constants.getKernel();

		// These fields are only instantiated, need to be connected to dslash variables
		writeEnable = dfeBool().newInstance(owner);

		write_t    = dfeUInt(MathUtils.bitsToAddress(T+2)) .newInstance(owner);
		write_z    = dfeUInt(MathUtils.bitsToAddress(LZ))  .newInstance(owner);
		write_y    = dfeUInt(MathUtils.bitsToAddress(LY))  .newInstance(owner);
		write_x    = dfeUInt(MathUtils.bitsToAddress(LX/2)).newInstance(owner);
		write_iter = dfeUInt(max(MathUtils.bitsToAddress(m_vectorsPerSite),1)).newInstance(owner);

		read_t    = dfeUInt(MathUtils.bitsToAddress(T+2)) .newInstance(owner);
		read_z    = dfeUInt(MathUtils.bitsToAddress(LZ))  .newInstance(owner);
		read_y    = dfeUInt(MathUtils.bitsToAddress(LY))  .newInstance(owner);
		read_x    = dfeUInt(MathUtils.bitsToAddress(LX/2)).newInstance(owner);
		read_iter = dfeUInt(max(MathUtils.bitsToAddress(m_vectorsPerSite),1)).newInstance(owner);
		m_ieo     = dfeBool().newInstance(owner);

		//create holds for buffer input and output
		m_bufferIn = new DFESu3Vector[m_numPipes];
		m_bufferOut = new DFESu3Vector[m_numPipes];
		for (int i=0 ; i<m_numPipes ; i++ ) {
			m_bufferIn[i] = new DFESu3Vector(m_constants);
		}

		//generate read and write addresses
		DFEVar[] readAddress = getReadAddresses(read_t, read_z, read_y, read_x, read_iter);
		DFEVar writeAddress  = getAddress( write_t, write_z, write_y, write_x, write_iter);

		//create the buffer
		m_bufferOut = createBuffer(
				m_bufferIn,
				writeAddress,
				readAddress,
				bufferDepth
				);
	}

	/**
	 * connect 4-D lattice coordination and loop iteration counter used for writing to the buffer
	 */
	public void setWriteCoordinates(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter) {
		write_t <== t;
		write_z <== z;
		write_y <== y;
		write_x <== x;
		write_iter <== iter;
	}

	/**
	 * connect 4-D lattice coordination and loop iteration counter used for reading from the buffer
	 * @param ieo reading halfspinors generated by even sites (ieo=1) or odd sites (ieo=0)
	 */
	public void setReadCoordinates(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter, DFEVar ieo) {
		m_ieo  <== ieo;
		read_t <== t;
		read_z <== z;
		read_y <== y;
		read_x <== x;
		read_iter <== iter;
	}

	/**
	 * connect the input halfspinor to the buffer
	 */
	public void setBufferIn(int pipe, DFESu3Vector in) {
		m_bufferIn[pipe] <== in;
	}

	/**
	 * connect the write enable signal to the buffer
	 */
	public void setWriteEnable(DFEVar isEnabled) {
		writeEnable <== isEnabled;
	}

	/**
	 * get the buffer output halfspinors for each pipe
	 * @param pipe the pipe index
	 * @return
	 */
	public DFESu3Vector getBufferOut (int pipe) {
		return m_bufferOut[pipe];
	}

	/**
	 * Calculate the remainder of dividing a DFE variable by an integer constant
	 * @param dividend DFE variable
	 * @param divisor  integer
	 * @return the remainder
	 */
	private DFEVar mod(DFEVar dividend, int divisor) {
		if (MathUtils.isPowerOf2(divisor)) {
			 //if divisor is a power of 2, remainder can be found by masking
			return (dividend & (divisor-1));
		} else {
			 //if divisor is not a power of 2, an actual division needs to be performed
			optimization.pushRoundingMode(RoundingMode.TRUNCATE);
			DFEVar divisor_ = constant.var(
					dfeUInt(MathUtils.bitsToRepresent(divisor)),
					divisor
					);
			DFEVar quotient = (dividend / divisor)
			                  .cast(dfeUInt(dividend.getType().getTotalBits()));
			DFEVar remainder = dividend - quotient * divisor_;
			optimization.popRoundingMode();
			return remainder;
		}
	}

	/**#
	 * find the maximum integer between the two inputs
	 */
	private int max (int a, int b) {
		if (a>= b) return a;
		else       return b;
	}

	/**
	 * Creates the buffer (lays out the FMEM organization)
	 * @return returns the halfspinors that are read from the buffer
	 */
	private DFESu3Vector[] createBuffer(
			DFESu3Vector[] halfSpinor_in,
            DFEVar writeAddress,
            DFEVar[] readAddress,
			int bufferDepth)
	{
		DFESu3Vector[] bufferOutput = new DFESu3Vector[m_numPipes];

		// create a seperate FMEM for each pipe, all pipes can read/write simultaneously
		// everything here is straight-forward, the "fun" stuff happens in address generation
		for (int i = 0 ; i < m_numPipes ; i ++ ) {
			DFEVector<DFEComplex> in = halfSpinor_in[i].convertToDFEVector();
			RamPortParams<DFEVector<DFEComplex>> writePort =
				mem.makeRamPortParams(
						RamPortMode.WRITE_ONLY,
						writeAddress,
						LQCDConstants.getVectoredSu3VectorType()
						)
						.withDataIn(in)
						.withWriteEnable(writeEnable);

			RamPortParams<DFEVector<DFEComplex>> readPort  =
				mem.makeRamPortParams(
						RamPortMode.READ_ONLY,
						readAddress[i],
						LQCDConstants.getVectoredSu3VectorType());

			DFEVector<DFEComplex> ram =
				mem.ramDualPort(
						bufferDepth,
						RamWriteMode.READ_FIRST,
						writePort,
						readPort)
						.getOutputB();

			bufferOutput[i] = new DFESu3Vector(m_constants, ram);

		}

		return bufferOutput;
	}

	/**
	 * Generates the addresses that are used to read from the buffer
	 * Inputs are read coordinates
	 * @return returns the addresses as an array, each address corresponds to a pipe
	 */
	private DFEVar[] getReadAddresses(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter) {

		DFEVar addresses[] = new DFEVar[m_numPipes];

		optimization.pushEnableBitGrowth(true);

		//This term is tricky, it is used for finding the neighbor site along x-axis
		//TODO full documentation
		DFEVar isOddRow = (t&1).cast(dfeBool()) ^ (z&1).cast(dfeBool()) ^ (y&1).cast(dfeBool()) ^ 1 ^ m_ieo;

		//find neighbor addresses in each direction and dimension
		DFEVar xn = mod(x + LX - 1 + isOddRow, LX/2).cast(dfeUInt(MathUtils.bitsToAddress(LX/2)));
		DFEVar xp = mod(x + LX + 0 + isOddRow, LX/2).cast(dfeUInt(MathUtils.bitsToAddress(LX/2)));
		DFEVar yn = mod(y + LY - 1, LY).cast(dfeUInt(MathUtils.bitsToAddress(LY)));
		DFEVar yp = mod(y + 1, LY).cast(dfeUInt(MathUtils.bitsToAddress(LY)));
		DFEVar zn = mod(z + LZ - 1, LZ).cast(dfeUInt(MathUtils.bitsToAddress(LZ)));
		DFEVar zp = mod(z + 1, LZ).cast(dfeUInt(MathUtils.bitsToAddress(LZ)));
		DFEVar tn = (t - 1).cast(dfeUInt(MathUtils.bitsToAddress(T+2)));
		DFEVar tp = (t + 1).cast(dfeUInt(MathUtils.bitsToAddress(T+2)));

		optimization.popEnableBitGrowth();

		DFEVar numPipes_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(m_numPipes)), m_numPipes);

		for (int pipe = 0 ; pipe < m_numPipes ; pipe ++ ) {

			DFEVar pipe_ = constant.var( dfeUInt( MathUtils.bitsToRepresent(m_numPipes)), pipe);

			optimization.pushEnableBitGrowth(true);
			DFEVar mu = (iter * numPipes_ + pipe_) >> 1;
			optimization.popEnableBitGrowth();

			//find the coordinate of the neighbor site for this pipe
			DFEVar xx, yy, zz, tt;
			xx = (mu === 0) ? xn : x;
			xx = (mu === 1) ? xp : xx;
			yy = (mu === 2) ? yn : y;
			yy = (mu === 3) ? yp : yy;
			zz = (mu === 4) ? zn : z;
			zz = (mu === 5) ? zp : zz;
			tt = (mu === 6) ? tn : t;
			tt = (mu === 7) ? tp : tt;

			//get the full address based on the neighbor coordinates
			addresses[pipe] = getAddress(tt, zz, yy, xx, iter);
		}


		return addresses;

	}

	/**
	 * This function generates the address based on 4-d coordinates used for both reading from and writing to the buffer
	 * @param t
	 * @param z
	 * @param y
	 * @param x
	 * @param iter
	 * @return
	 */
	public DFEVar getAddress(DFEVar t, DFEVar z, DFEVar y, DFEVar x, DFEVar iter) {

		DFEVar LZ_  = constant.var(dfeUInt(MathUtils.bitsToRepresent(LZ)),LZ);
		DFEVar LY_  = constant.var(dfeUInt(MathUtils.bitsToRepresent(LY)),LY);
		DFEVar LXH_ = constant.var(dfeUInt(MathUtils.bitsToRepresent(LX/2)),LX/2);

		optimization.pushEnableBitGrowth(true);

		DFEVar address = ( ( ( ( t*LZ_ + z) * LY_ + y) * LXH_ + x) * m_vectorsPerSite + iter );
		address = mod(address, bufferDepth);  //wrap around, whenever passed the buffer capacity

		optimization.popEnableBitGrowth();
		return address.cast(dfeUInt(MathUtils.bitsToAddress(bufferDepth)));
	}


}
