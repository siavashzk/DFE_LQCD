package lqcd;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.RoundingMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.LMemCommandStream;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.CounterChain;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEStruct;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

public class AddressGeneratorSpinor extends Kernel {

	public AddressGeneratorSpinor(
			KernelParameters params,
			int T,
			int XYZ,
			int cmdSize,
			String cmdOutName) {

		super(params);

		DFEStruct cmd = LMemCommandStream.getLMemCommandDFEStructType().newInstance(this);
		DFEType addressType = (DFEType)cmd["address"].getType();

		DFEVar startAddress = io.scalarInput("startAddress", addressType);
		DFEVar halos = io.scalarInput("halos", addressType);

		int SpinorSize = 4 * 3 * 2 * 32 / 8;  // 72B

		if ((XYZ*SpinorSize) % 384 != 0) {
			throw new RuntimeException("Lattice space volume must be burst aligned.");
		}

		DFEVar numTimesSlice = T + 2 * halos;
		int burstsPerT = (XYZ*SpinorSize) / 384;

		if ( burstsPerT % cmdSize != 0) {
			throw new RuntimeException("Memory command size must divide the number of burts in a lattice space volume");
		}

		CounterChain chain = control.count.makeCounterChain();
		DFEVar t   = chain.addCounter(numTimesSlice, 1);
		DFEVar xyz = chain.addCounter(burstsPerT, cmdSize);

		optimization.pushEnableBitGrowth(true);

		DFEVar tt = mod(t + T - halos,T);

		DFEVar address = (startAddress + tt * burstsPerT + xyz).cast(addressType);

		optimization.popEnableBitGrowth();

		/*address.simWatch("address");
		commandCount.simWatch("cmdCnt");*/

		cmd["address"] = address;
		cmd["size"]    = constant.var((DFEType)cmd["size"].getType(),   cmdSize);
		cmd["inc"]     = constant.var((DFEType)cmd["inc"].getType(),    1);
		cmd["stream"]  = constant.var((DFEType)cmd["stream"].getType(), 1);
		cmd["tag"]     = (t === (numTimesSlice - 1) & xyz === (burstsPerT - cmdSize) );
		LMemCommandStream.makeKernelOutput(cmdOutName, constant.var(true), cmd);

	}

	private DFEVar mod(DFEVar dividend, int divisor) {
		if (MathUtils.isPowerOf2(divisor)) {
			return (dividend & (divisor-1));
		} else {
			optimization.pushRoundingMode(RoundingMode.TRUNCATE);
			DFEVar divisor_ = constant.var(
					dfeUInt(MathUtils.bitsToRepresent(divisor)),
					divisor
					);
			DFEVar quotient = (dividend / divisor)
			                  .cast(dfeUInt(dividend.getType().getTotalBits()));
			DFEVar remainder = dividend - quotient * divisor_;
			optimization.popRoundingMode();
			return remainder;
		}
	}

}
